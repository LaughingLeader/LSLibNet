// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, John Gough, QUT 2005-2014
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.5.2
// Machine:  LL-GAME
// DateTime: 12/12/2025 12:47:25 AM
// UserName: LaughingLeader
// Input file <C:\Projects\CSharp\LSLibNet\src\LSLibStats\Stats\Functor\RollConditions.yy - 12/11/2025 11:26:13 PM>

// options: lines

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gppg;

namespace LSLib.Stats.RollConditions;

public enum RollConditionTokens
{
	error = 95, EOF = 96,
	NAME = 97, TEXT = 98
};

[GeneratedCodeAttribute("Gardens Point Parser Generator", "1.5.2")]
public partial class RollConditionParser : ShiftReduceParser<System.Object, LexLocation>
{
#pragma warning disable 649
	private static Dictionary<int, string> aliases;
#pragma warning restore 649
	private static Rule[] rules = new Rule[16];
	private static State[] states = new State[19];
	private static string[] nonTerms = new string[] {
	  "Root", "$accept", "RollConditions", "RollConditionOrEmpty", "RollCondition",
	  "Expression", };

	static RollConditionParser()
	{
		states[0] = new State(new int[] { 97, 7, 98, 16, 59, -5, 96, -5 }, new int[] { -1, 1, -3, 3, -4, 18, -5, 6 });
		states[1] = new State(new int[] { 96, 2 });
		states[2] = new State(-1);
		states[3] = new State(new int[] { 59, 4, 96, -2 });
		states[4] = new State(new int[] { 97, 7, 98, 16, 59, -5, 96, -5 }, new int[] { -4, 5, -5, 6 });
		states[5] = new State(-4);
		states[6] = new State(-6);
		states[7] = new State(new int[] { 91, 8, 97, 13, 98, 14, 59, -8, 96, -8 }, new int[] { -6, 15 });
		states[8] = new State(new int[] { 97, 13, 98, 14 }, new int[] { -6, 9 });
		states[9] = new State(new int[] { 93, 10, 97, 11, 98, 12 });
		states[10] = new State(-7);
		states[11] = new State(-14);
		states[12] = new State(-15);
		states[13] = new State(-12);
		states[14] = new State(-13);
		states[15] = new State(new int[] { 97, 11, 98, 12, 59, -10, 96, -10 });
		states[16] = new State(new int[] { 97, 13, 98, 14, 59, -9, 96, -9 }, new int[] { -6, 17 });
		states[17] = new State(new int[] { 97, 11, 98, 12, 59, -11, 96, -11 });
		states[18] = new State(-3);

		for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

		rules[1] = new Rule(-2, new int[] { -1, 96 });
		rules[2] = new Rule(-1, new int[] { -3 });
		rules[3] = new Rule(-3, new int[] { -4 });
		rules[4] = new Rule(-3, new int[] { -3, 59, -4 });
		rules[5] = new Rule(-4, new int[] { });
		rules[6] = new Rule(-4, new int[] { -5 });
		rules[7] = new Rule(-5, new int[] { 97, 91, -6, 93 });
		rules[8] = new Rule(-5, new int[] { 97 });
		rules[9] = new Rule(-5, new int[] { 98 });
		rules[10] = new Rule(-5, new int[] { 97, -6 });
		rules[11] = new Rule(-5, new int[] { 98, -6 });
		rules[12] = new Rule(-6, new int[] { 97 });
		rules[13] = new Rule(-6, new int[] { 98 });
		rules[14] = new Rule(-6, new int[] { -6, 97 });
		rules[15] = new Rule(-6, new int[] { -6, 98 });
	}

	protected override void Initialize()
	{
		this.InitSpecialTokens((int)RollConditionTokens.error, (int)RollConditionTokens.EOF);
		this.InitStates(states);
		this.InitRules(rules);
		this.InitNonTerminals(nonTerms);
	}

	protected override void DoAction(int action)
	{
#pragma warning disable 162, 1522
		switch (action)
		{
			case 3: // RollConditions -> RollConditionOrEmpty
#line 19 "C:\Projects\CSharp\LSLibNet\src\LSLibStats\Stats\Functor\RollConditions.yy"
				{ CurrentSemanticValue = AddCondition(MakeConditions(), ValueStack[ValueStack.Depth - 1]); }
#line default
				break;
			case 4: // RollConditions -> RollConditions, ';', RollConditionOrEmpty
#line 20 "C:\Projects\CSharp\LSLibNet\src\LSLibStats\Stats\Functor\RollConditions.yy"
				{ CurrentSemanticValue = AddCondition(ValueStack[ValueStack.Depth - 3], ValueStack[ValueStack.Depth - 1]); }
#line default
				break;
			case 7: // RollCondition -> NAME, '[', Expression, ']'
#line 27 "C:\Projects\CSharp\LSLibNet\src\LSLibStats\Stats\Functor\RollConditions.yy"
				{ CurrentSemanticValue = MakeCondition(ValueStack[ValueStack.Depth - 4], ValueStack[ValueStack.Depth - 2]); }
#line default
				break;
			case 10: // RollCondition -> NAME, Expression
#line 30 "C:\Projects\CSharp\LSLibNet\src\LSLibStats\Stats\Functor\RollConditions.yy"
				{ CurrentSemanticValue = ConcatExpression(ValueStack[ValueStack.Depth - 2], ValueStack[ValueStack.Depth - 1]); }
#line default
				break;
			case 11: // RollCondition -> TEXT, Expression
#line 31 "C:\Projects\CSharp\LSLibNet\src\LSLibStats\Stats\Functor\RollConditions.yy"
				{ CurrentSemanticValue = ConcatExpression(ValueStack[ValueStack.Depth - 2], ValueStack[ValueStack.Depth - 1]); }
#line default
				break;
			case 14: // Expression -> Expression, NAME
#line 36 "C:\Projects\CSharp\LSLibNet\src\LSLibStats\Stats\Functor\RollConditions.yy"
				{ CurrentSemanticValue = ConcatExpression(ValueStack[ValueStack.Depth - 2], ValueStack[ValueStack.Depth - 1]); }
#line default
				break;
			case 15: // Expression -> Expression, TEXT
#line 37 "C:\Projects\CSharp\LSLibNet\src\LSLibStats\Stats\Functor\RollConditions.yy"
				{ CurrentSemanticValue = ConcatExpression(ValueStack[ValueStack.Depth - 2], ValueStack[ValueStack.Depth - 1]); }
#line default
				break;
		}
#pragma warning restore 162, 1522
	}

	protected override string TerminalToString(int terminal)
	{
		if (aliases != null && aliases.ContainsKey(terminal))
			return aliases[terminal];
		else if (((RollConditionTokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
			return ((RollConditionTokens)terminal).ToString();
		else
			return CharToString((char)terminal);
	}

}
